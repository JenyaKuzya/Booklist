unit Lib;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Data.DB, Vcl.StdCtrls, Vcl.Grids,
  Vcl.DBGrids;

type
  bk = ^TBookList;
  TBook = record
    Author, NameOfBook: string[255];
    Year: Integer;
  end;
  TBookList = record
    Element: TBook;
    next, prev: bk;
  end;
  sav = file of TBook;

var
  first: Bk;
  F: sav;

procedure showdata (const first: Bk; var strg: TStringGrid);
procedure Addrecord (var first: bk; const Author, Name: string; const Year: integer);
procedure Deletelist (var q: bk);
procedure DeleteBook(const first: bk; const ARow: integer);

implementation

uses Records;

procedure showdata(const first: Bk; var strg: TStringGrid);
var
  q: bk;
  i: Integer;
begin
  strg.RowCount := 1;
  q := first;
  i := 1;
  while q^.next <> nil do
  begin
    q := q^.next;
    with strg do
    begin
      RowCount := RowCount + 1;
      Cells[0,i] := q^.Element.Author;
      Cells[1,i] := q^.Element.NameOfBook;
      Cells[2,i] := IntToStr(q^.Element.Year);
    end;
    Inc(i);
  end;
end;

procedure Addrecord (var first: bk; const Author, Name: string; const Year: integer);
var
  q: bk;
begin
  New(q);
  if first^.next <> nil then
  begin
    q^.next := first^.next;
    first^.next^.prev := q;
  end
  else
    q^.next := nil;
  first^.next := q;
  q^.Element.Author := Author;
  q^.Element.NameOfBook := Name;
  q^.Element.Year := Year;
  q^.prev := first;
end;

procedure Deletelist (var q: bk);
begin
  while q^.next <> nil do
  begin
    q := q^.next;
    dispose(q^.prev);
  end;
  dispose(q);
end;

procedure DeleteBook(const first: bk; const ARow: integer);
var
  q: bk;
  el: TBook;
begin
  el.Author := FRecord.StringGrid1.cells[0,ARow];
  el.NameOfBook := FRecord.StringGrid1.cells[1,ARow];
  el.Year := StrToInt(FRecord.StringGrid1.cells[2,ARow]);
  q := first;
  while (el.Author <> q^.Element.Author) and (el.NameOfBook <> q^.Element.NameOfBook) and (el.Year <> q^.Element.Year) do
    q := q^.next;
  if q^.next <> nil then
  begin
    q^.prev^.next := q^.next;
    q^.next^.prev := q^.prev;
  end
  else
  begin
    q^.prev^.next := nil;
  end;
  Dispose(q);
end;

end.
